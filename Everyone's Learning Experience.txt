Please write a few sentences about what you have learned through this project. 
The content here will be copied to the end of the Project document.

Songyang Li:
I learned about designing an application from scratch, using diagrams, use cases and everthing we learned in class.
I understand the importance of keeping track of progress and version control. 
While the coding was not extremely challenging, the important thing was how to design the project and convert the design to codes.

Ryan Lira:
A lot of the difficulty of the project was organizing all of our schedules and responsibilities. With a group of six people, there was no single time slot when everybody could meet up each week, and, after the mess that was the first iteration, we had to work hard to not let the entire group fall into disarray. Software engineering is a lot of tuning and tweaking, which is difficult for any one person to do, but each piece of the project would also require some knowledge of the whole system, which is difficult to establish with a group. We learned to manage this, get everybody to understand how the system worked, and we even learned how to distribute this work evenly and effortlessly so that new additions were painless.

Thiphavanh Phoutthivongsack:
I learned that time management is really important when it come to a group project. When having a big group, getting everyone together to work on the project. Having a big group, I've learn how to move my schedule around to beable to go to the group meeting. With project design, I've learned how to design a software, and how each step from the requirements and use cases, to sequence diagrams and class diagrams are depending on each other. When all of those diagrams are matching it make coding to not be challenging. 

Alexander Kermani:
	It took some time for me to gain traction with this (and every other) class, but I’ve learned a lot. Before, I knew absolutely nothing about software engineering, other than the fact that it is somehow related to computer science. Gradually, a broad understanding that it was a type of “divide and conquer” approach to problems that were far too complex for one person to flow-chart and program began to unfold, and that the goal was to take a formulaic approach to a process that (in my mind) amounts to setting up the framework for the programming to happen and integrate smoothly through multiple iterations. This means that everything happens more quickly, more correctly, and more completely during the execution (PQCT). To accomplish this, the software engineers meet with the client to try to formulate an understanding of the program requirements and constraints (allocation), refine and expand upon those requirements (analysis), determine the proper architecture (design), then test and implement/maintain the system. This is done iteratively (with an Agile approach) as more features and capabilities are added to the system. After the requirements are clarified, they’re broken down into use cases, which are diagrammed (use case diagrams and traceability matrix) and used to derive the domain model, which is used to design the architecture and the sequence diagram, which is used to draw up the class diagram. I really feel like I get object oriented design, for the first time in my academic career. I’m not the best at it, but I actually understand it, now.
